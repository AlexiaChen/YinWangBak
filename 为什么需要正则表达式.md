#为什么需要正则表达式

作者：王垠

学习Unix最开头，大家都学过正则表达式(regexp)。可是有没有人考虑过我们为什么需要正则表达式？

正则表达式本来的初衷是用来从无结构的字符串中提取信息，殊不知这正好是Unix的缺陷所在。Unix用无结构的字符串来表示数据，导致了诸多复杂的基于regexp的软件的诞生。sed, AWK, Perl, ... 都是为了同样的目的来到这个世界上的。如果不是因为Unix用字符串来表示数据，我们就会拥有按数据结构类型的直接存储，而不需要折腾regexp。正则表达式有它自己的价值（针对自然语言），但是我们其实不需要把它应用到程序语言和操作系统里面。

正则表达式本身用一个字符串来表示，这带来另外一些问题。因为正则表达式的本质不是字符串，而是一个数据结构。学过计算理论的人可能知道这个数据结构叫做NFA（nondeterministic finite automaton，非确定性有限自动机）。所有的数据结构应该由程序语言本身来表示，就像用Java构造一个对象用 new ClassA("a") 一样。但是正则表达式强迫你把这个简单的构造函数调用写成一个字符串。所以在这个比方之下，你得写成 "new ClassA(\"a\")"。这样当你想要组合这些表达式的时候就发现，正则表达式几乎都是不可组合(compose)的。你几乎不可能不能把两个regexp的变量A和B安全拼接成一个，比如用Java的字符串拼接A+B。因为你不知道这两个字符串拼在一起之后，那些稀奇古怪的符号会出现什么交叉反应，使得最后的识别的东西根本不是你想要的。

在正则表达式中，由于正则表达式本身的构造函数与数据本身合并到一起，我们不得不对某些“特殊字符”进行escape。这些特殊字符，其实是用来描述NFA的记号，它们属于更高一层的语言。可是在正则表达式里，它们与NFA节点里的字符混为一谈。比如很简单的一个block comment的正则表达式，却要写成这个样子：

"/\\*([^\\*]|[^/])*\\*/"

显然这样的表达式很容易出错。 如果我们用程序语言的表达式来构造这个表达式，它应该是这样：


[图片缺少]


在这个我自己设计的Scheme表达式里，以@开头的标识符都是构造函数。其中 @...是构造sequence，@* 是构造一个zero-or-more的匹配，@!构造一个否定匹配。这个表达式是说：“以 / * 开头，接着零个或者多个不是 * / 的字符，最后接着一个 * /。这样一来清晰明了，什么表达式在什么“层次”都很清楚，不需要什么反斜杠escape，而且这样的表达式可以compose。比如:

[图片缺少]

定义这三个表达式之后，我们之后可以用像 (@... reg1 (@or reg2 reg3)) 这样的表达式来连接3个不同的表达式，构造出更大的表达式。这样的构造可以无限的扩展。从这里以及以往的经验，我总结出一个普遍适用的程序设计的教训：尽量不要把多个层次的语言“压缩”到一层。我们也看到正则表达式与“Unix哲学”有很大关系。我没有考古，所以不知道孰先孰后，但是它们肯定有直接的因果关系。两者都是Unix复杂性的来源。
